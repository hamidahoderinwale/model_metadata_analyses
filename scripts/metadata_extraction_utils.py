import pandas as pd\nimport numpy as np\nimport json\nimport re\nimport logging\nfrom datetime import datetime\nfrom typing import Any, Optional, Tuple\n\n# Set up logging (optional, can be configured in main script)\nlogger = logging.getLogger(__name__)\n# Prevent propagation to the root logger if the main script configures it\n# If not configured, this logger will use the default handler/config\nif not logger.handlers:\n    logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\')\n    logger = logging.getLogger(__name__)\n\n\ndef extract_parameters_from_metadata(metadata_str: Any) -> float:\n    \"\"\"\n    Extract parameter count from metadata string.\n    Handles NaN, non-string inputs, JSON/YAML formats, string patterns,\n    and various parameter keys/suffixes.\n    \"\"\"\n    if pd.isna(metadata_str):\n        return np.nan\n\n    if not isinstance(metadata_str, str):\n        logger.debug(f\"Metadata is not a string (type: {type(metadata_str)}): {metadata_str}\")\n        return np.nan\n\n    # Clean the string for easier parsing\n    cleaned_str = metadata_str.strip()\n\n    # Try parsing as JSON\n    try:\n        metadata = json.loads(cleaned_str)\n        if isinstance(metadata, dict):\n            # Try common parameter keys in JSON\n            param_keys = [\'parameters\', \'parameter_count\', \'num_parameters\', \'total_parameters\', \'size\', \'model_size\']\n            for key in param_keys:\n                if key in metadata:\n                    value = metadata[key]\n                    if isinstance(value, (int, float)):\n                        return float(value)\n                    elif isinstance(value, str):\n                        # Handle string values with K/M/B suffixes in JSON\n                        value_lower = value.lower().replace(\',\', \'\').strip()\n                        try:\n                            if \'b\' in value_lower:\n                                return float(value_lower.replace(\'b\', \'\')) * 1e9\n                            elif \'m\' in value_lower:\n                                return float(value_lower.replace(\'m\', \'\')) * 1e6\n                            elif \'k\' in value_lower:\n                                return float(value_lower.replace(\'k\', \'\')) * 1e3\n                            else:\n                                return float(value_lower)\n                        except ValueError:\n                            logger.debug(f\"Could not parse string parameter value \'{value}\' from JSON.\")\n                            continue # Try next key or pattern\n\n    except json.JSONDecodeError:\n        logger.debug(\"Metadata is not valid JSON. Proceeding with regex/string parsing.\")\n        pass # Not JSON, continue to string/regex parsing\n\n    # If not JSON or parameter not found in JSON, try string/regex parsing\n    # Look for patterns like \"7B parameters\", \"1.5B params\", etc.\n    patterns = [\n        r\'(\\d+(?:\\.\\d+)?)\\s*[Bb]\\s*(?:parameters?|params?)\',  # 7B parameters\n        r\'(\\d+(?:\\.\\d+)?)\\s*[Mm]\\s*(?:parameters?|params?)\',  # 500M parameters\n        r\'(\\d+(?:\\.\\d+)?)\\s*[Kk]\\s*(?:parameters?|params?)\',  # 100K parameters\n        r\'total\\s*size\\s*:\\s*(\\d+(?:\\.\\d+)?)\\s*[Bb]\', # total size : 7B\n        r\'total\\s*size\\s*:\\s*(\\d+(?:\\.\\d+)?)\\s*[Mm]\', # total size : 500M\n        r\'total\\s*size\\s*:\\s*(\\d+(?:\\.\\d+)?)\\s*[Kk]\', # total size : 100K\n        r\'total\\s*:\\s*(\\d+(?:\\.\\d+)?)\', # safetensors total: 123456\n        r\'(\\d+(?:\\.\\d+)?)\\s*(?:parameters?|params?)\'          # plain numbers anywhere\n    ]\n\n    for pattern in patterns:\n        match = re.search(pattern, cleaned_str.lower())\n        if match:\n            try:\n                value = float(match.group(1))\n                if \'b\' in pattern.lower():\n                    return value * 1e9\n                elif \'m\' in pattern.lower():\n                    return value * 1e6\n                elif \'k\' in pattern.lower():\n                    return value * 1e3\n                else:\n                    # Check if the pattern is one of the \'total size\' or \'total\' patterns\n                    if \'total size\' in pattern.lower() or \'total :\' in pattern.lower():\n                         # These patterns already imply the correct scale, no need for k/m/b check\n                         return value\n                    # For generic plain numbers, assume it\'s the raw count if no suffix\n                    return value\n            except ValueError:\n                logger.debug(f\"Could not convert regex match \'{match.group(1)}\' to float.\")\n                continue\n\n    logger.debug(f\"No parameter information found in metadata string: {metadata_str}\")\n    return np.nan\n\ndef extract_date_from_metadata(metadata_str: Any, date_type: str) -> Optional[datetime]:\n    \"\"\"\n    Extracts created_at or last_modified date from metadata string.\n    Handles NaN, non-string inputs, JSON/YAML formats, and various date keys.\n    Returns a timezone-naive datetime object or None if extraction fails.\n    \"\"\"\n    if pd.isna(metadata_str):\n        return None\n\n    if not isinstance(metadata_str, str):\n        logger.debug(f\"Metadata is not a string (type: {type(metadata_str)}): {metadata_str}\")\n        return None\n\n    cleaned_str = metadata_str.strip()\n    date_keys = {\n        \'created_at\': [\'created_at\', \'model_created_at\', \'createdAt\', \'modelCreatedAt\'],\n        \'last_modified\': [\'last_modified\', \'model_last_modified\', \'lastModified\', \'modelLastModified\']\n    }\n\n    # Try parsing as JSON\n    try:\n        metadata = json.loads(cleaned_str)\n        if isinstance(metadata, dict):\n            for key in date_keys.get(date_type, []):\n                if key in metadata:\n                    date_value = metadata[key]\n                    if isinstance(date_value, str):\n                        try:\n                            # Parse date string, assume timezone-naive\n                            dt_obj = datetime.fromisoformat(date_value.replace(\'Z\', \'+00:00\')).replace(tzinfo=None)\n                            return dt_obj\n                        except ValueError:\n                            logger.debug(f\"Could not parse date string \'{date_value}\' for key \'{key}\' from JSON.\")\n                            continue # Try next key\n\n    except json.JSONDecodeError:\n        logger.debug(\"Metadata is not valid JSON. Proceeding with string parsing.\")\n        pass # Not JSON, continue to string parsing\n\n    # If not JSON or date not found in JSON, try string parsing (less reliable)\n    # Look for common date patterns in the string\n    # This is a fallback and may not be accurate\n    date_pattern = r\'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})?\' # ISO 8601 like\n    match = re.search(date_pattern, cleaned_str)\n    if match:\n        try:\n            # Parse date string, assume timezone-naive\n            dt_obj = datetime.fromisoformat(match.group(0).replace(\'Z\', \'+00:00\')).replace(tzinfo=None)\n            return dt_obj\n        except ValueError:\n            logger.debug(f\"Could not parse date string \'{match.group(0)}\' from raw string.\")\n            pass\n\n    logger.debug(f\"No {date_type} information found in metadata string: {metadata_str}\")\n    return None\n\n\ndef extract_model_family(model_id: str, metadata_str: Any) -> Tuple[str, str]:\n    \"\"\"\n    Extract model family using both model ID and metadata information.\n    Returns a tuple of (family, confidence) where confidence is \'high\' or \'low\'.\n    Handles NaN and non-string metadata inputs.\n    \"\"\"\
    if pd.isna(model_id) or pd.isna(metadata_str) or not isinstance(metadata_str, str):\n        return \"Unknown\", \"low\"\n\n    cleaned_metadata_str = metadata_str.strip()\n\n    # First try to get family from metadata (JSON)\n    try:\n        metadata = json.loads(cleaned_metadata_str)\n        if isinstance(metadata, dict):\n            # Check for explicit architecture information\n            arch_keys = [\'architecture\', \'model_type\', \'model_architecture\', \'model_family\', \'library_name\']\n            for key in arch_keys:\n                if key in metadata:\n                    arch = str(metadata[key]).lower()\n                    # Map common architecture names/library names to families\n                    if \'transformers\' in arch: return \"Transformer (Library)\", \"high\" # Added library check\n                    if \'bert\' in arch: return \"BERT\", \"high\"\n                    elif \'gpt\' in arch: return \"GPT\", \"high\"\n                    elif \'t5\' in arch: return \"T5\", \"high\"\n                    elif \'roberta\' in arch: return \"RoBERTa\", \"high\"\n                    elif \'llama\' in arch: return \"LLaMA\", \"high\"\n                    elif \'mistral\' in arch: return \"Mistral\", \"high\"\n                    elif \'falcon\' in arch: return \"Falcon\", \"high\"\n                    elif \'bloom\' in arch: return \"BLOOM\", \"high\"\n                    elif \'opt\' in arch: return \"OPT\", \"high\"\n                    elif \'mpt\' in arch: return \"MPT\", \"high\"\n                    elif \'phi\' in arch: return \"Phi\", \"high\"\n                    elif \'gemma\' in arch: return \"Gemma\", \"high\"\n                    elif \'qwen\' in arch: return \"Qwen\", \"high\"\n                    elif \'yi\' in arch: return \"Yi\", \"high\"\n                    elif \'baichuan\' in arch: return \"Baichuan\", \"high\"\n                    elif \'chatglm\' in arch: return \"ChatGLM\", \"high\"\n                    elif \'internlm\' in arch: return \"InternLM\", \"high\"\n                    elif \'deepseek\' in arch: return \"DeepSeek\", \"high\"\n                    elif \'stablelm\' in arch: return \"StableLM\", \"high\"\n                    elif \'openllama\' in arch: return \"OpenLLaMA\", \"high\"\n                    elif \'pythia\' in arch: return \"Pythia\", \"high\"\n                    elif \'cerebras\' in arch: return \"Cerebras\", \"high\"\n                    elif \'mamba\' in arch: return \"Mamba\", \"high\"\n                    elif \'recurrent\' in arch: return \"Recurrent\", \"low\"\n                    elif \'rwkv\' in arch: return \"RWKV\", \"high\"\n                    elif \'transformer\' in arch: return \"Transformer\", \"low\" # Generic transformer\n    except json.JSONDecodeError:\n        logger.debug(\"Metadata is not valid JSON for family extraction.\")\n        pass\n\n    # If metadata doesn\'t help, try model ID\n    model_id_lower = str(model_id).lower()\n\n    # Define model family patterns with their confidence levels\n    family_patterns = {\n        \'bert\': (\'BERT\', \'high\'),\n        \'gpt\': (\'GPT\', \'high\'),\n        \'t5\': (\'T5\', \'high\'),\n        \'roberta\': (\'RoBERTa\', \'high\'),\n        \'llama\': (\'LLaMA\', \'high\'),\n        \'mistral\': (\'Mistral\', \'high\'),\n        \'falcon\': (\'Falcon\', \'high\'),\n        \'bloom\': (\'BLOOM\', \'high\'),\n        \'opt\': (\'OPT\', \'high\'),\n        \'gpt2\': (\'GPT-2\', \'high\'),\n        \'gpt-j\': (\'GPT-J\', \'high\'),\n        \'gpt-neo\': (\'GPT-Neo\', \'high\'),\n        \'gpt-neox\': (\'GPT-NeoX\', \'high\'),\n        \'mpt\': (\'MPT\', \'high\'),\n        \'phi\': (\'Phi\', \'high\'),\n        \'gemma\': (\'Gemma\', \'high\'),\n        \'qwen\': (\'Qwen\', \'high\'),\n        \'yi\': (\'Yi\', \'high\'),\n        \'baichuan\': (\'Baichuan\', \'high\'),\n        \'chatglm\': (\'ChatGLM\', \'high\'),\n        \'internlm\': (\'InternLM\', \'high\'),\n        \'deepseek\': (\'DeepSeek\', \'high\'),\n        \'stablelm\': (\'StableLM\', \'high\'),\n        \'openllama\': (\'OpenLLaMA\', \'high\'),\n        \'pythia\': (\'Pythia\', \'high\'),\n        \'cerebras\': (\'Cerebras\', \'high\'),\n        \'mamba\': (\'Mamba\', \'high\'),\n        \'recurrent\': (\'Recurrent\', \'low\'),\n        \'rwkv\': (\'RWKV\', \'high\'),\n        \'transformer\': (\'Transformer\', \'low\') # Generic transformer in ID\n    }\n\n    # Check for pattern matches in model ID\n    for pattern, (family, confidence) in family_patterns.items():\n        if pattern in model_id_lower:\n            return family, confidence\n\n    # Check for organization-specific patterns in model ID\n    org_patterns = {\n        \'meta-ai\': \'Meta\',\n        \'google\': \'Google\',\n        \'microsoft\': \'Microsoft\',\n        \'huggingface\': \'HuggingFace\',\n        \'stabilityai\': \'StabilityAI\',\n        \'deepmind\': \'DeepMind\',\n        \'openai\': \'OpenAI\',\n        \'anthropic\': \'Anthropic\',\n        \'cohere\': \'Cohere\',\n        \'nvidia\': \'NVIDIA\',\n        \'amazon\': \'Amazon\',\n        \'apple\': \'Apple\',\n        \'salesforce\': \'Salesforce\',\n        \'facebook\': \'Meta\',\n        \'alibaba\': \'Alibaba\',\n        \'tencent\': \'Tencent\',\n        \'baidu\': \'Baidu\'\n    }\n\n    for org, family in org_patterns.items():\n        if org in model_id_lower:\n            return f\"{family} Model\", \"low\" # Label as low confidence if only org is matched\n\n    return \"Other\", \"low\"\n\n\ndef extract_architecture_type(metadata_str: Any) -> str:\n    \"\"\"Extract architecture type from metadata.\"\"\"\
    if pd.isna(metadata_str) or not isinstance(metadata_str, str):\n        return \"Unknown\"\n\n    cleaned_str = metadata_str.strip()\n\n    try:\n        metadata = json.loads(cleaned_str)\n        if isinstance(metadata, dict):\n            # Check for architecture information\n            arch_keys = [\'architecture\', \'model_type\', \'model_architecture\', \'library_name\']\n            for key in arch_keys:\n                if key in metadata:\n                    # Return the value directly for more detail\n                    return str(metadata[key])\n    except json.JSONDecodeError:\n         logger.debug(\"Metadata is not valid JSON for architecture extraction.\")\n         pass # Not JSON, return Unknown for now\n\n    return \"Unknown\" 
